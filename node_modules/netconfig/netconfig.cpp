#include <v8.h>
#include <node.h>

#include <list>
#include <string>

#if defined(sun) || defined(__sun)
#  if defined(__SVR4) || defined(__svr4__)
#    define OS_SOLARIS 1
#  endif
#endif

#ifdef OS_SOLARIS
#  include <libdllink.h>
#else
#  include <stdlib.h>
#  include <string.h>
#  include <sys/socket.h>
#  include <sys/ioctl.h>
#  include <net/if.h>
#  include <arpa/inet.h>
#  include <netinet/in.h>
#  include <unistd.h>
#endif

using namespace node;
using namespace v8;

class NetConfig: ObjectWrap
{
	private:
		std::list<std::string> interfaces;
#ifdef OS_SOLARIS
		dladm_handle_t g_handle;

		int dladm_init() {
			dladm_status_t dlstat;
			char errmsg[DLADM_STRSIZE];

			dlstat = dladm_open(&this->g_handle);
			if (dlstat != DLADM_STATUS_OK) {
				fprintf(stderr, "dladm_open: %s\n", dladm_status2str(dlstat, errmsg));
				return 1;
			}
			return 0;
		}

		int dladm_finish() {
			dladm_status_t dlstat;
			char errmsg[DLADM_STRSIZE];

			dladm_close(this->g_handle);
			return 0;
		}

		static int dladm_callback(dladm_handle_t dh, datalink_id_t linkid, void *obj) {
			dladm_status_t		status;
			char			link[MAXLINKNAMELEN];
			datalink_class_t	dl_class;
			uint32_t		flags;
			NetConfig *o = (NetConfig *)(obj);

			if ((status = dladm_datalink_id2info(o->g_handle, linkid, &flags, &dl_class,
			    NULL, link, sizeof (link))) != DLADM_STATUS_OK) {
				return (status);
			}

			o->interfaces.push_back(link);

			return (DLADM_WALK_CONTINUE);
		}

		void load_if_list(void) {
			dladm_init();
			this->interfaces.clear();

			uint32_t flags = DLADM_OPT_ACTIVE;
			(void) dladm_walk_datalink_id(dladm_callback, this->g_handle,
			    this, (datalink_class_t) DATALINK_CLASS_ALL, DATALINK_ANY_MEDIATYPE,
			    flags);
			dladm_finish();
			return;
		}
#else

#ifndef _SIZEOF_ADDR_IFREQ
#define _SIZEOF_ADDR_IFREQ sizeof
#endif

		void load_if_list(void) {
			int socketfd;
			struct ifconf conf;
			char data[4096];
			struct ifreq *ifr;
			// char addrbuf[1024];

			this->interfaces.clear();
			socketfd = socket(AF_INET, SOCK_DGRAM, 0);
			if (socketfd >= 0) {
				conf.ifc_len = sizeof(data);
				conf.ifc_buf = (caddr_t) data;
				if (ioctl(socketfd,SIOCGIFCONF,&conf) < 0)
					perror("ioctl");

				ifr = (struct ifreq*)data;
				while ((char*)ifr < data+conf.ifc_len) {
					switch (ifr->ifr_addr.sa_family) {
						case AF_INET:
							// printf("%s : %s\n", ifr->ifr_name, inet_ntop(ifr->ifr_addr.sa_family, &((struct sockaddr_in*)&ifr->ifr_addr)->sin_addr, addrbuf, sizeof(addrbuf)));
							// printf("%s\n", ifr->ifr_name);
							this->interfaces.push_back(ifr->ifr_name);
							break;
					}
					ifr = (struct ifreq*)((char*)ifr +_SIZEOF_ADDR_IFREQ(*ifr));
				}
				close(socketfd);
			}
		}
#endif

	public:
		static Persistent<FunctionTemplate> s_ct;

		static void Init(Handle<Object> target) {
			HandleScope scope;

			Local<FunctionTemplate> t = FunctionTemplate::New(New);

			s_ct = Persistent<FunctionTemplate>::New(t);
			s_ct->InstanceTemplate()->SetInternalFieldCount(1);
			s_ct->SetClassName(String::NewSymbol("NetConfig"));

			NODE_SET_PROTOTYPE_METHOD(s_ct, "getAllInterfaces", getAllInterfaces);

			target->Set(String::NewSymbol("NetConfig"), s_ct->GetFunction());
		}

		NetConfig() { }
		~NetConfig() { }

		static Handle<Value> New(const Arguments& args) {
			HandleScope scope;
			NetConfig* hw = new NetConfig();
			hw->Wrap(args.This());
			return args.This();
		}

		static Handle<Value> getAllInterfaces(const Arguments& args) {
			HandleScope scope;
			NetConfig* netconf = ObjectWrap::Unwrap<NetConfig>(args.This());
			int i = 0;
			std::list<std::string>::const_iterator it;
			netconf->load_if_list();
			Local<Array> result = Array::New();
			for (it=netconf->interfaces.begin(); it!=netconf->interfaces.end(); it++) {
				result->Set(Number::New(i++), String::New((*it).c_str()));
			}
			return scope.Close(result);
		}
};

Persistent<FunctionTemplate> NetConfig::s_ct;

extern "C" {
	static void init (Handle<Object> target) {
		NetConfig::Init(target);
	}
	NODE_MODULE(netconfig, init);
}
